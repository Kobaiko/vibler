'use client'

import React, { useState, useRef, useEffect, useCallback, useMemo } from 'react'
import { Button } from '@/components/ui/Button'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/Card'
import { Badge } from '@/components/ui/Badge'
import { 
  Type, 
  Image as ImageIcon, 
  Palette, 
  Move, 
  RotateCw, 
  Square, 
  Circle, 
  Save, 
  Download, 
  Undo, 
  Redo,
  Plus,
  Trash2,
  Eye,
  EyeOff,
  AlignLeft,
  AlignCenter,
  AlignRight,
  Bold,
  Italic,
  Underline,
  Layers,
  Settings,
  Brush,
  Triangle,
  Hexagon,
  Star,
  Upload,
  X,
  Sparkles,
  RefreshCw,
  MousePointer2,
  MoveIcon,
  Maximize2
} from 'lucide-react'

interface LayerStyle {
  fontSize?: number
  fontFamily?: string
  color?: string
  backgroundColor?: string
  borderRadius?: number
  padding?: number
  textAlign?: 'left' | 'center' | 'right'
  fontWeight?: 'normal' | 'bold' | '600' | '700'
  textShadow?: string
  border?: string
  opacity?: number
  zIndex: number
}

interface Layer {
  id: string
  type: 'text' | 'button' | 'image' | 'shape' | 'background'
  content: string
  x: number
  y: number
  width: number
  height: number
  rotation?: number
  visible?: boolean
  locked?: boolean
  style: LayerStyle
  zIndex: number
  shapeType?: 'rectangle' | 'circle' | 'triangle' | 'hexagon' | 'star' | 'rounded-rectangle'
  imageUrl?: string
  imageShape?: 'rectangle' | 'circle' | 'rounded-rectangle'
  colorOverlay?: {
    enabled: boolean
    color: string
    opacity: number
  }
}

interface Creative {
  id: string
  platform: string
  format: string
  headline: string
  description: string
  call_to_action: string
  image_url: string
  targeting: string
  campaign_type: string
  dimensions: string // e.g., "300x250"
  composition?: {
    baseImage: string
    finalComposition: string
    layers: any[]
    dimensions: { width: number; height: number }
  }
}

interface LayeredAdEditorProps {
  creative: Creative
  brandSettings?: {
    primaryColor: string
    secondaryColor: string
    brandName: string
  }
  onSave: (layers: Layer[], imageDataUrl: string) => void
  onCancel: () => void
}

const LayeredAdEditor: React.FC<LayeredAdEditorProps> = ({ creative, brandSettings, onSave, onCancel }) => {
  const canvasRef = useRef<HTMLCanvasElement>(null)
  const [layers, setLayers] = useState<Layer[]>([])
  const [selectedLayerId, setSelectedLayerId] = useState<string | null>(null)
  const [isDragging, setIsDragging] = useState(false)
  const [isResizing, setIsResizing] = useState(false)
  const [dragStart, setDragStart] = useState({ x: 0, y: 0 })
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 })
  const [resizeHandle, setResizeHandle] = useState<string | null>(null)
  const [showPreview, setShowPreview] = useState(false)
  const [backgroundImageShape, setBackgroundImageShape] = useState<'rectangle' | 'circle' | 'rounded-rectangle'>('rectangle')
  const [backgroundOverlay, setBackgroundOverlay] = useState({
    enabled: true,
    color: '#000000',
    opacity: 0.3
  })
  const [isLoading, setIsLoading] = useState(true)
  const [activeTab, setActiveTab] = useState<'layers' | 'design' | 'export'>('layers')
  const [showAddLayerMenu, setShowAddLayerMenu] = useState(false)
  const [uploadingImage, setUploadingImage] = useState(false)
  const [lastMousePos, setLastMousePos] = useState({ x: 0, y: 0 })
  const [canvasBackgroundColor, setCanvasBackgroundColor] = useState('#ffffff')

  // Platform-specific ad dimensions (matching server-side configs - no video/carousel)
  const platformDimensions = {
    linkedin: {
      'Single Image Ad': { width: 1200, height: 627 },
      'Sponsored Content': { width: 1200, height: 627 }
    },
    facebook: {
      'Feed Ad': { width: 1200, height: 630 },
      'Story Ad': { width: 1080, height: 1920 }
    },
    instagram: {
      'Feed Post': { width: 1080, height: 1080 },
      'Story Ad': { width: 1080, height: 1920 }
    },
    google: {
      'Display Banner': { width: 728, height: 90 },
      'Medium Rectangle': { width: 300, height: 250 },
      'Large Rectangle': { width: 336, height: 280 },
      'Leaderboard': { width: 728, height: 90 },
      'Wide Skyscraper': { width: 160, height: 600 },
      'Mobile Banner': { width: 320, height: 50 }
    },
    email: {
      'Email Header': { width: 600, height: 200 },
      'Email Banner': { width: 600, height: 400 },
      'Newsletter Header': { width: 650, height: 250 },
      'Email Footer': { width: 600, height: 150 }
    }
  }

  // Use creative's actual dimensions instead of platform selector
  const canvasSize = useMemo(() => {
    let dimensions = { width: 1200, height: 630 } // Default fallback
    
    // First try to use the creative's composition dimensions if available
    if (creative.composition?.dimensions) {
      dimensions = creative.composition.dimensions
    }
    // Otherwise, parse the dimensions string from the creative (e.g., "300x250")
    else if ((creative as any).dimensions && typeof (creative as any).dimensions === 'string') {
      const [width, height] = (creative as any).dimensions.split('x').map(Number)
      if (width && height) {
        dimensions = { width, height }
        console.log(`ðŸŽ¨ LayeredAdEditor using parsed dimensions:`, {
          original: (creative as any).dimensions,
          parsed: dimensions,
          format: creative.format
        })
      }
    }
    
    // Scale down for display while maintaining aspect ratio
    // Use different max sizes for different aspect ratios
    const aspectRatio = dimensions.width / dimensions.height
    let maxDisplaySize = 600
    
    // For very tall formats (like Wide Skyscraper), allow larger height
    if (aspectRatio < 0.5) { // Very tall formats
      maxDisplaySize = 800
    }
    // For very wide formats, keep normal max size
    else if (aspectRatio > 3) { // Very wide formats
      maxDisplaySize = 600
    }
    
    let { width, height } = dimensions
    
    if (width > maxDisplaySize || height > maxDisplaySize) {
      const scale = Math.min(maxDisplaySize / width, maxDisplaySize / height)
      width = Math.round(width * scale)
      height = Math.round(height * scale)
    }
    
    return { width, height, originalWidth: dimensions.width, originalHeight: dimensions.height }
  }, [creative.composition?.dimensions, (creative as any).dimensions, creative.format])

  // Initialize layers and canvas
  useEffect(() => {
    if (creative.composition?.layers) {
      // Convert composition layers to editor layers
      const editorLayers: Layer[] = [
        // Background layer
        {
          id: 'background',
          type: 'background',
          content: '',
          x: 0,
          y: 0,
          width: 100,
          height: 100,
          visible: true,
          locked: false,
          style: { zIndex: 0, opacity: 1 },
          zIndex: 0,
          imageUrl: creative.image_url,
          shapeType: backgroundImageShape,
          colorOverlay: backgroundOverlay
        },
        // Convert composition layers
        ...creative.composition.layers.map((layer: any, index: number) => ({
          id: layer.id || `layer-${index}`,
          type: layer.type || 'text',
          content: layer.content || '',
          x: layer.position?.x || 10,
          y: layer.position?.y || 10,
          width: layer.size?.width || 80,
          height: layer.size?.height || 20,
          rotation: 0,
          visible: true,
          locked: false,
          style: {
            ...layer.style,
            zIndex: layer.style?.zIndex || index + 1,
            opacity: 1
          },
          zIndex: layer.style?.zIndex || index + 1
        }))
      ]
      setLayers(editorLayers)
    } else {
      // Create default layers
      const defaultLayers: Layer[] = [
        {
          id: 'background',
          type: 'background',
          content: '',
          x: 0,
          y: 0,
          width: 100,
          height: 100,
          visible: true,
          locked: false,
          style: { zIndex: 0, opacity: 1 },
          zIndex: 0,
          imageUrl: creative.image_url,
          shapeType: backgroundImageShape,
          colorOverlay: backgroundOverlay
        },
        {
          id: 'headline',
          type: 'text',
          content: creative.headline,
          x: 10,
          y: 15,
          width: 80,
          height: 20,
          visible: true,
          locked: false,
          style: {
            fontSize: 28,
            fontFamily: 'Arial, sans-serif',
            color: '#ffffff',
            fontWeight: 'bold',
            textAlign: 'center',
            textShadow: '2px 2px 4px rgba(0,0,0,0.8)',
            zIndex: 1,
            opacity: 1
          },
          zIndex: 1
        },
        {
          id: 'description',
          type: 'text',
          content: creative.description,
          x: 10,
          y: 40,
          width: 80,
          height: 25,
          visible: true,
          locked: false,
          style: {
            fontSize: 16,
            fontFamily: 'Arial, sans-serif',
            color: '#ffffff',
            fontWeight: 'normal',
            textAlign: 'center',
            textShadow: '1px 1px 2px rgba(0,0,0,0.8)',
            zIndex: 2,
            opacity: 1
          },
          zIndex: 2
        },
        {
          id: 'cta',
          type: 'button',
          content: creative.call_to_action || 'Learn More',
          x: 30,
          y: 75,
          width: 40,
          height: 12,
          visible: true,
          locked: false,
          style: {
            fontSize: 14,
            fontFamily: 'Arial, sans-serif',
            color: '#ffffff',
            backgroundColor: brandSettings?.primaryColor || '#3b82f6',
            borderRadius: 8,
            padding: 8,
            fontWeight: 'bold',
            textAlign: 'center',
            zIndex: 3,
            opacity: 1
          },
          zIndex: 3
        }
      ]
      setLayers(defaultLayers)
    }
    
    // Stop loading state
    setIsLoading(false)
  }, [creative, brandSettings, backgroundImageShape, backgroundOverlay])

  // Redraw canvas when layers change
  useEffect(() => {
    drawCanvas()
  }, [layers, backgroundImageShape, backgroundOverlay, showPreview])

  // Canvas drawing function
  const drawCanvas = useCallback(() => {
    const canvas = canvasRef.current
    if (!canvas) return
    
    const ctx = canvas.getContext('2d')
    if (!ctx) return
    
    // Clear canvas with canvas background color
    ctx.fillStyle = canvasBackgroundColor
    ctx.fillRect(0, 0, canvas.width, canvas.height)
    
    // Draw layers in z-index order
    const sortedLayers = [...layers].sort((a, b) => a.zIndex - b.zIndex)
    
    // Split layers into background and non-background
    const backgroundLayers = sortedLayers.filter(layer => layer.type === 'background')
    const otherLayers = sortedLayers.filter(layer => layer.type !== 'background')
    
    // Draw background layers first
    backgroundLayers.forEach(layer => {
      if (!layer.visible) return
      
      const x = (layer.x / 100) * canvas.width
      const y = (layer.y / 100) * canvas.height
      const width = (layer.width / 100) * canvas.width
      const height = (layer.height / 100) * canvas.height
      
      ctx.save()
      ctx.globalAlpha = layer.style.opacity || 1
      
      if (layer.imageUrl) {
        const img = new Image()
        img.crossOrigin = 'anonymous'
        img.onload = () => {
          ctx.save()
          
          // Apply shape clipping
          if (backgroundImageShape === 'circle') {
            ctx.beginPath()
            ctx.arc(x + width / 2, y + height / 2, Math.min(width, height) / 2, 0, 2 * Math.PI)
            ctx.clip()
          } else if (backgroundImageShape === 'rounded-rectangle') {
            const radius = 20
            ctx.beginPath()
            ctx.roundRect(x, y, width, height, radius)
            ctx.clip()
          }
          
          ctx.drawImage(img, x, y, width, height)
          
          // Apply color overlay
          if (backgroundOverlay.enabled) {
            ctx.fillStyle = backgroundOverlay.color
            ctx.globalAlpha = backgroundOverlay.opacity
            ctx.fillRect(x, y, width, height)
          }
          
          ctx.restore()
          
          // Draw selection outline for background layer
          if (layer.id === selectedLayerId && !showPreview) {
            drawSelectionOutline(ctx, x, y, width, height)
          }
          
          // IMPORTANT: Draw all other layers after background image loads
          drawOtherLayers(ctx, otherLayers)
        }
        img.src = layer.imageUrl
      }
      
      ctx.restore()
    })
    
    // If no background images, draw other layers immediately
    if (backgroundLayers.length === 0 || !backgroundLayers.some(l => l.imageUrl)) {
      drawOtherLayers(ctx, otherLayers)
    }
  }, [layers, backgroundImageShape, backgroundOverlay, showPreview, selectedLayerId, canvasBackgroundColor])
  
  // Helper function to draw non-background layers
  const drawOtherLayers = (ctx: CanvasRenderingContext2D, otherLayers: Layer[]) => {
    const canvas = canvasRef.current
    if (!canvas) return
    
    otherLayers.forEach(layer => {
      if (!layer.visible) return
      
      const x = (layer.x / 100) * canvas.width
      const y = (layer.y / 100) * canvas.height
      const width = (layer.width / 100) * canvas.width
      const height = (layer.height / 100) * canvas.height
      
      ctx.save()
      ctx.globalAlpha = layer.style.opacity || 1
      
      if (layer.type === 'background' && layer.imageUrl) {
        // Draw background image
        const img = new Image()
        img.crossOrigin = 'anonymous'
        img.onload = () => {
          ctx.save()
          
          // Apply shape clipping
          if (backgroundImageShape === 'circle') {
            ctx.beginPath()
            ctx.arc(x + width / 2, y + height / 2, Math.min(width, height) / 2, 0, 2 * Math.PI)
            ctx.clip()
          } else if (backgroundImageShape === 'rounded-rectangle') {
            const radius = 20
            ctx.beginPath()
            ctx.roundRect(x, y, width, height, radius)
            ctx.clip()
          } else {
            // Rectangle clipping
            ctx.beginPath()
            ctx.rect(x, y, width, height)
            ctx.clip()
          }
          
          // Draw background image
          ctx.drawImage(img, x, y, width, height)
          
          // Apply color overlay
          if (backgroundOverlay.enabled) {
            ctx.fillStyle = backgroundOverlay.color
            ctx.globalAlpha = backgroundOverlay.opacity
            ctx.fillRect(x, y, width, height)
          }
          
          ctx.restore()
          
          // Draw selection outline for background layer
          if (layer.id === selectedLayerId && !showPreview) {
            drawSelectionOutline(ctx, x, y, width, height)
          }
        }
        img.src = layer.imageUrl
      }
      
      if (layer.type === 'image' && layer.imageUrl) {
        // Draw uploaded image layer
        const img = new Image()
        img.crossOrigin = 'anonymous'
        img.onload = () => {
          ctx.save()
          
          // Apply shape clipping for image layers
          if (layer.imageShape === 'circle') {
            ctx.beginPath()
            ctx.arc(x + width / 2, y + height / 2, Math.min(width, height) / 2, 0, 2 * Math.PI)
            ctx.clip()
          } else if (layer.imageShape === 'rounded-rectangle') {
            const radius = 10
            ctx.beginPath()
            ctx.roundRect(x, y, width, height, radius)
            ctx.clip()
          }
          
          // Draw the image
          ctx.drawImage(img, x, y, width, height)
          
          // Apply color overlay if enabled
          if (layer.colorOverlay?.enabled) {
            ctx.fillStyle = layer.colorOverlay.color
            ctx.globalAlpha = layer.colorOverlay.opacity
            ctx.fillRect(x, y, width, height)
          }
          
          ctx.restore()
          
          // Draw selection outline
          if (layer.id === selectedLayerId && !showPreview) {
            drawSelectionOutline(ctx, x, y, width, height)
          }
        }
        img.src = layer.imageUrl
      }
      
      if (layer.type === 'text') {
        // Draw text layer with better visibility
        const fontSize = Math.max(12, (layer.style.fontSize || 16) * (canvas.width / 400)) // Scale font size
        ctx.font = `${layer.style.fontWeight || 'bold'} ${fontSize}px ${layer.style.fontFamily || 'Arial, sans-serif'}`
        ctx.fillStyle = layer.style.color || '#ffffff'
        ctx.textAlign = (layer.style.textAlign || 'center') as CanvasTextAlign
        ctx.textBaseline = 'top'
        
        // Apply text shadow for better visibility
        ctx.shadowOffsetX = 2
        ctx.shadowOffsetY = 2
        ctx.shadowBlur = 4
        ctx.shadowColor = 'rgba(0,0,0,0.8)'
        
        // Word wrap for long text
        const words = layer.content.split(' ')
        const lines = []
        let currentLine = ''
        
        for (const word of words) {
          const testLine = currentLine + (currentLine ? ' ' : '') + word
          const metrics = ctx.measureText(testLine)
          if (metrics.width > width && currentLine) {
            lines.push(currentLine)
            currentLine = word
          } else {
            currentLine = testLine
          }
        }
        if (currentLine) lines.push(currentLine)
        
        // Draw each line
        const lineHeight = fontSize * 1.2
        lines.forEach((line, index) => {
          const lineY = y + (index * lineHeight)
          let lineX = x
          
          // Adjust x position based on text alignment
          if (layer.style.textAlign === 'center') {
            lineX = x + width / 2
          } else if (layer.style.textAlign === 'right') {
            lineX = x + width
          }
          
          ctx.fillText(line, lineX, lineY)
        })
        
        // Reset shadow
        ctx.shadowOffsetX = 0
        ctx.shadowOffsetY = 0
        ctx.shadowBlur = 0
        ctx.shadowColor = 'transparent'
      }
      
      if (layer.type === 'button') {
        // Draw button background
        ctx.fillStyle = layer.style.backgroundColor || '#3b82f6'
        const radius = layer.style.borderRadius || 8
        ctx.beginPath()
        ctx.roundRect(x, y, width, height, radius)
        ctx.fill()
        
        // Draw button text with proper sizing
        let fontSize = Math.max(10, (layer.style.fontSize || 14) * (canvas.width / 400))
        ctx.font = `${layer.style.fontWeight || 'bold'} ${fontSize}px ${layer.style.fontFamily || 'Arial, sans-serif'}`
        
        // Ensure text fits within button bounds with padding
        const textPadding = 16 // pixels of padding
        const maxTextWidth = width - textPadding
        const textMetrics = ctx.measureText(layer.content)
        
        // Scale down font size if text is too wide
        if (textMetrics.width > maxTextWidth) {
          fontSize = Math.max(8, fontSize * (maxTextWidth / textMetrics.width))
          ctx.font = `${layer.style.fontWeight || 'bold'} ${fontSize}px ${layer.style.fontFamily || 'Arial, sans-serif'}`
        }
        
        // Ensure text doesn't exceed button height
        const maxTextHeight = height * 0.6 // 60% of button height
        if (fontSize > maxTextHeight) {
          fontSize = Math.max(8, maxTextHeight)
          ctx.font = `${layer.style.fontWeight || 'bold'} ${fontSize}px ${layer.style.fontFamily || 'Arial, sans-serif'}`
        }
        
        ctx.fillStyle = layer.style.color || '#ffffff'
        ctx.textAlign = 'center'
        ctx.textBaseline = 'middle'
        
        ctx.fillText(layer.content, x + width / 2, y + height / 2)
      }
      
      if (layer.type === 'shape') {
        ctx.fillStyle = layer.style.backgroundColor || '#6366f1'
        
        if (layer.shapeType === 'circle') {
          ctx.beginPath()
          ctx.arc(x + width / 2, y + height / 2, Math.min(width, height) / 2, 0, 2 * Math.PI)
          ctx.fill()
        } else if (layer.shapeType === 'triangle') {
          ctx.beginPath()
          ctx.moveTo(x + width / 2, y)
          ctx.lineTo(x, y + height)
          ctx.lineTo(x + width, y + height)
          ctx.closePath()
          ctx.fill()
        } else if (layer.shapeType === 'rounded-rectangle') {
          const radius = layer.style.borderRadius || 10
          ctx.beginPath()
          ctx.roundRect(x, y, width, height, radius)
          ctx.fill()
        } else {
          // Default rectangle
          ctx.fillRect(x, y, width, height)
        }
        
        // Apply color overlay if enabled
        if (layer.colorOverlay?.enabled) {
          ctx.fillStyle = layer.colorOverlay.color
          ctx.globalAlpha = layer.colorOverlay.opacity
          ctx.fillRect(x, y, width, height)
        }
      }
      
      // Draw selection outline for all non-background layers
      if (layer.id === selectedLayerId && !showPreview) {
        drawSelectionOutline(ctx, x, y, width, height)
      }
      
      ctx.restore()
    })
  }

  // Helper function to draw selection outline and resize handles
  const drawSelectionOutline = (ctx: CanvasRenderingContext2D, x: number, y: number, width: number, height: number) => {
    ctx.strokeStyle = '#3b82f6'
    ctx.lineWidth = 2
    ctx.setLineDash([5, 5])
    ctx.strokeRect(x - 2, y - 2, width + 4, height + 4)
    ctx.setLineDash([])
    
    // Draw resize handles
    const handleSize = 8
    ctx.fillStyle = '#3b82f6'
    ctx.strokeStyle = '#ffffff'
    ctx.lineWidth = 1
    
    // Corner handles
    ctx.fillRect(x - handleSize/2, y - handleSize/2, handleSize, handleSize)
    ctx.strokeRect(x - handleSize/2, y - handleSize/2, handleSize, handleSize)
    
    ctx.fillRect(x + width - handleSize/2, y - handleSize/2, handleSize, handleSize)
    ctx.strokeRect(x + width - handleSize/2, y - handleSize/2, handleSize, handleSize)
    
    ctx.fillRect(x - handleSize/2, y + height - handleSize/2, handleSize, handleSize)
    ctx.strokeRect(x - handleSize/2, y + height - handleSize/2, handleSize, handleSize)
    
    ctx.fillRect(x + width - handleSize/2, y + height - handleSize/2, handleSize, handleSize)
    ctx.strokeRect(x + width - handleSize/2, y + height - handleSize/2, handleSize, handleSize)
  }

  // Mouse event handlers for canvas interaction
  const handleMouseDown = (e: React.MouseEvent<HTMLCanvasElement>) => {
    const canvas = canvasRef.current
    if (!canvas) return
    
    const rect = canvas.getBoundingClientRect()
    const scaleX = canvas.width / rect.width
    const scaleY = canvas.height / rect.height
    const x = (e.clientX - rect.left) * scaleX
    const y = (e.clientY - rect.top) * scaleY
    
    // Find clicked layer (reverse order to check top layers first)
    const sortedLayers = [...layers].sort((a, b) => b.zIndex - a.zIndex)
    let clickedLayer = null
    
    for (const layer of sortedLayers) {
      if (!layer.visible) continue
      
      const layerX = (layer.x / 100) * canvas.width
      const layerY = (layer.y / 100) * canvas.height
      const layerWidth = (layer.width / 100) * canvas.width
      const layerHeight = (layer.height / 100) * canvas.height
      
      // Check if click is within layer bounds
      if (x >= layerX && x <= layerX + layerWidth && y >= layerY && y <= layerY + layerHeight) {
        clickedLayer = layer
        break
      }
    }
    
    if (clickedLayer) {
      setSelectedLayerId(clickedLayer.id)
      
      const layerX = (clickedLayer.x / 100) * canvas.width
      const layerY = (clickedLayer.y / 100) * canvas.height
      const layerWidth = (clickedLayer.width / 100) * canvas.width
      const layerHeight = (clickedLayer.height / 100) * canvas.height
      
      // Check for resize handle clicks
      const handleSize = 8
      const handles = [
        { x: layerX - handleSize/2, y: layerY - handleSize/2, type: 'nw' },
        { x: layerX + layerWidth - handleSize/2, y: layerY - handleSize/2, type: 'ne' },
        { x: layerX - handleSize/2, y: layerY + layerHeight - handleSize/2, type: 'sw' },
        { x: layerX + layerWidth - handleSize/2, y: layerY + layerHeight - handleSize/2, type: 'se' }
      ]
      
      const clickedHandle = handles.find(handle => 
        x >= handle.x && x <= handle.x + handleSize &&
        y >= handle.y && y <= handle.y + handleSize
      )
      
      if (clickedHandle) {
        setIsResizing(true)
        setResizeHandle(clickedHandle.type)
      } else {
        setIsDragging(true)
      }
      
      setDragStart({ x, y })
      setLastMousePos({ x, y })
    } else {
      setSelectedLayerId(null)
    }
  }

  const handleMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!isDragging && !isResizing) return
    
    const canvas = canvasRef.current
    if (!canvas) return
    
    const rect = canvas.getBoundingClientRect()
    const scaleX = canvas.width / rect.width
    const scaleY = canvas.height / rect.height
    const x = (e.clientX - rect.left) * scaleX
    const y = (e.clientY - rect.top) * scaleY
    
    const deltaX = x - lastMousePos.x
    const deltaY = y - lastMousePos.y
    
    if (selectedLayerId && (isDragging || isResizing)) {
      setLayers(prev => prev.map(layer => {
        if (layer.id !== selectedLayerId) return layer
        
        if (isDragging) {
          // Convert pixel deltas to percentage
          const deltaXPercent = (deltaX / canvas.width) * 100
          const deltaYPercent = (deltaY / canvas.height) * 100
          
          return {
            ...layer,
            x: Math.max(0, Math.min(100 - layer.width, layer.x + deltaXPercent)),
            y: Math.max(0, Math.min(100 - layer.height, layer.y + deltaYPercent))
          }
        }
        
        if (isResizing) {
          const deltaXPercent = (deltaX / canvas.width) * 100
          const deltaYPercent = (deltaY / canvas.height) * 100
          
          let newLayer = { ...layer }
          
          switch (resizeHandle) {
            case 'se': // Southeast
              newLayer.width = Math.max(5, Math.min(100 - layer.x, layer.width + deltaXPercent))
              newLayer.height = Math.max(5, Math.min(100 - layer.y, layer.height + deltaYPercent))
              break
            case 'ne': // Northeast
              newLayer.width = Math.max(5, Math.min(100 - layer.x, layer.width + deltaXPercent))
              newLayer.y = Math.max(0, layer.y + deltaYPercent)
              newLayer.height = Math.max(5, layer.height - deltaYPercent)
              break
            case 'sw': // Southwest
              newLayer.x = Math.max(0, layer.x + deltaXPercent)
              newLayer.width = Math.max(5, layer.width - deltaXPercent)
              newLayer.height = Math.max(5, Math.min(100 - layer.y, layer.height + deltaYPercent))
              break
            case 'nw': // Northwest
              newLayer.x = Math.max(0, layer.x + deltaXPercent)
              newLayer.y = Math.max(0, layer.y + deltaYPercent)
              newLayer.width = Math.max(5, layer.width - deltaXPercent)
              newLayer.height = Math.max(5, layer.height - deltaYPercent)
              break
          }
          
          // For text layers, scale font size with height changes
          if (layer.type === 'text' && newLayer.height !== layer.height) {
            const heightRatio = newLayer.height / layer.height
            const currentFontSize = layer.style.fontSize || 16
            newLayer.style = {
              ...layer.style,
              fontSize: Math.max(8, Math.min(72, currentFontSize * heightRatio))
            }
          }
          
          return newLayer
        }
        
        return layer
      }))
    }
    
    setLastMousePos({ x, y })
  }

  const handleMouseUp = () => {
    setIsDragging(false)
    setIsResizing(false)
    setResizeHandle(null)
  }

  // Add new layer
  const addLayer = (type: 'text' | 'image' | 'shape' | 'button') => {
    if (type === 'image') {
      // Trigger file input for image upload
      const input = document.createElement('input')
      input.type = 'file'
      input.accept = 'image/*'
      input.onchange = (e) => {
        const file = (e.target as HTMLInputElement).files?.[0]
        if (file) {
          handleImageUpload(file)
        }
      }
      input.click()
      return
    }

    const newLayer: Layer = {
      id: `layer-${Date.now()}`,
      type: type === 'button' ? 'button' : type,
      content: type === 'text' ? 'New Text' : type === 'button' ? 'Click Here' : type === 'shape' ? '' : '',
      x: 20,
      y: 20,
      width: type === 'text' ? 60 : type === 'button' ? 40 : 30,
      height: type === 'text' ? 15 : type === 'button' ? 12 : 30,
      rotation: 0,
      visible: true,
      locked: false,
      style: {
        fontSize: type === 'button' ? 14 : 16,
        fontFamily: 'Arial, sans-serif',
        color: '#ffffff',
        backgroundColor: type === 'button' ? '#3b82f6' : type === 'shape' ? '#6366f1' : undefined,
        fontWeight: type === 'button' ? 'bold' : 'normal',
        textAlign: 'center',
        borderRadius: type === 'button' ? 8 : undefined,
        padding: type === 'button' ? 12 : undefined,
        zIndex: Math.max(...layers.map(l => l.zIndex)) + 1,
        opacity: 1
      },
      zIndex: Math.max(...layers.map(l => l.zIndex)) + 1,
      shapeType: type === 'shape' ? 'rectangle' : undefined
    }
    
    setLayers(prev => [...prev, newLayer])
    setSelectedLayerId(newLayer.id)
  }

  // Handle image upload for new image layers
  const handleImageUpload = async (file: File) => {
    setUploadingImage(true)
    try {
      const reader = new FileReader()
      reader.onload = (e) => {
        const imageUrl = e.target?.result as string
        const newLayer: Layer = {
          id: `image-${Date.now()}`,
          type: 'image',
          content: '',
          x: 20,
          y: 20,
          width: 40,
          height: 40,
          rotation: 0,
          visible: true,
          locked: false,
          style: {
            zIndex: Math.max(...layers.map(l => l.zIndex)) + 1,
            opacity: 1
          },
          zIndex: Math.max(...layers.map(l => l.zIndex)) + 1,
          imageUrl,
          imageShape: 'rectangle',
          colorOverlay: { enabled: false, color: '#000000', opacity: 0.3 }
        }
        setLayers(prev => [...prev, newLayer])
        setSelectedLayerId(newLayer.id)
        drawCanvas()
      }
      reader.readAsDataURL(file)
    } catch (error) {
      console.error('Error uploading image:', error)
    } finally {
      setUploadingImage(false)
    }
  }

  // Export canvas as image
  const exportImage = () => {
    const canvas = canvasRef.current
    if (!canvas) return
    
    // Temporarily clear selection for clean export
    const originalSelection = selectedLayerId
    setSelectedLayerId(null)
    
    setTimeout(() => {
      const dataUrl = canvas.toDataURL('image/png')
      onSave(layers, dataUrl)
      setSelectedLayerId(originalSelection)
    }, 100)
  }

  // Download image
  const downloadImage = () => {
    const canvas = canvasRef.current
    if (!canvas) return
    
    // Temporarily clear selection for clean export
    const originalSelection = selectedLayerId
    setSelectedLayerId(null)
    
    setTimeout(() => {
      const dataUrl = canvas.toDataURL('image/png')
      const link = document.createElement('a')
      link.download = `${creative.platform}-creative.png`
      link.href = dataUrl
      link.click()
      setSelectedLayerId(originalSelection)
    }, 100)
  }

  const selectedLayer = layers.find(l => l.id === selectedLayerId)

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-96">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-600 mx-auto mb-4"></div>
          <p>Loading editor...</p>
        </div>
      </div>
    )
  }

  return (
    <div className="flex h-screen bg-gray-50">
      {/* Canvas Area */}
      <div className="flex-1 flex items-center justify-center p-4">
        <div className="relative bg-white rounded-lg shadow-lg p-4">
          <canvas
            ref={canvasRef}
            width={canvasSize.width}
            height={canvasSize.height}
            className={`border border-gray-200 rounded ${
              isResizing ? 'cursor-nw-resize' : isDragging ? 'cursor-move' : 'cursor-crosshair'
            }`}
            style={{ maxWidth: '600px', maxHeight: '600px' }}
            onMouseDown={handleMouseDown}
            onMouseMove={handleMouseMove}
            onMouseUp={handleMouseUp}
            onMouseLeave={handleMouseUp}
          />
          

        </div>
      </div>

      {/* Right Panel */}
      <div className="w-96 bg-white border-l border-gray-200 overflow-y-auto">
        
        {/* Header */}
        <div className="p-4 border-b border-gray-200">
          <div className="flex items-center justify-between mb-2">
            <h2 className="text-lg font-semibold text-gray-800">Edit {creative.platform} Creative</h2>
            <Button size="sm" variant="ghost" onClick={onCancel}>
              <X className="w-4 h-4" />
            </Button>
          </div>
          <p className="text-sm text-gray-500">Click on any layer to edit its properties</p>
        </div>

        {/* Layer Management */}
        <div className="p-4">

          {/* Creative Format Display */}
          <div className="mb-6 p-4 bg-gray-50 rounded-lg">
            <h4 className="font-medium text-gray-800 mb-3">Creative Format</h4>
            
            <div className="space-y-2">
              <div className="flex justify-between items-center">
                <span className="text-sm font-medium text-gray-600">Platform:</span>
                <span className="text-sm text-gray-800 capitalize">{creative.platform}</span>
              </div>
              <div className="flex justify-between items-center">
                <span className="text-sm font-medium text-gray-600">Format:</span>
                <span className="text-sm text-gray-800">{creative.format}</span>
              </div>
              <div className="flex justify-between items-center">
                <span className="text-sm font-medium text-gray-600">Dimensions:</span>
                <span className="text-sm text-gray-800">
                  {canvasSize.originalWidth} Ã— {canvasSize.originalHeight}px
                </span>
              </div>
            </div>
          </div>

          {/* Add Layer Buttons - Above the layers */}
          <div className="mb-6">
            <h4 className="font-medium text-gray-800 mb-3">Add Elements</h4>
            <p className="text-xs text-gray-600 mb-3">Click to add new layers to your design</p>
            <div className="grid grid-cols-2 gap-2">
              <Button 
                size="sm" 
                variant="outline"
                onClick={() => addLayer('text')}
                className="flex items-center justify-center gap-2 py-2 text-purple-600 border-purple-200"
              >
                <Type className="w-4 h-4" />
                Add Text
              </Button>
              <Button 
                size="sm" 
                variant="outline"
                onClick={() => addLayer('button')}
                className="flex items-center justify-center gap-2 py-2 text-purple-600 border-purple-200"
              >
                <Square className="w-4 h-4" />
                Add Button
              </Button>
              <Button 
                size="sm" 
                variant="outline"
                onClick={() => addLayer('shape')}
                className="flex items-center justify-center gap-2 py-2 text-purple-600 border-purple-200"
              >
                <Circle className="w-4 h-4" />
                Add Shape
              </Button>
              <Button 
                size="sm" 
                variant="outline"
                onClick={() => addLayer('image')}
                className="flex items-center justify-center gap-2 py-2 text-purple-600 border-purple-200"
              >
                <ImageIcon className="w-4 h-4" />
                Add Image
              </Button>
            </div>
          </div>

          {/* Text Layers */}
          <div className="space-y-3">
            {layers.filter(layer => layer.type === 'text' || layer.type === 'button').map((layer, index) => (
              <div key={layer.id} className="space-y-2">
                <div
                  className={`p-3 rounded-lg border cursor-pointer transition-all ${
                    selectedLayerId === layer.id 
                      ? 'border-pink-300 bg-pink-50' 
                      : 'border-gray-200 hover:border-gray-300'
                  }`}
                  onClick={() => setSelectedLayerId(selectedLayerId === layer.id ? null : layer.id)}
                >
                  <div className="flex items-center justify-between mb-2">
                    <span className="text-sm font-medium text-gray-700 truncate max-w-[180px]">
                      {layer.content || `${layer.type} layer`}
                    </span>
                    <div className="flex items-center gap-1">
                      <span className="text-xs text-gray-400 bg-gray-100 px-2 py-1 rounded">{index + 1}</span>
                      <Button
                        size="sm"
                        variant="ghost"
                        onClick={(e) => {
                          e.stopPropagation()
                          setLayers(prev => prev.map(l => 
                            l.id === layer.id ? { ...l, visible: !l.visible } : l
                          ))
                        }}
                        className="p-1 h-6 w-6"
                      >
                        {layer.visible ? <Eye className="w-3 h-3" /> : <EyeOff className="w-3 h-3" />}
                      </Button>
                      <Button
                        size="sm"
                        variant="ghost"
                        onClick={(e) => {
                          e.stopPropagation()
                          setLayers(prev => prev.filter(l => l.id !== layer.id))
                          if (selectedLayerId === layer.id) {
                            setSelectedLayerId(null)
                          }
                        }}
                        className="p-1 h-6 w-6"
                      >
                        <Trash2 className="w-3 h-3" />
                      </Button>
                    </div>
                  </div>
                  
                  {/* Optional indicator for type */}
                  {layer.type === 'button' && (
                    <div className="text-xs text-gray-500">
                      Call to Action Icon
                      <Button size="sm" variant="outline" className="ml-2 text-xs px-2 py-1 h-6">
                        Select
                      </Button>
                    </div>
                  )}
                </div>

                {/* Layer Properties - Show directly below selected layer */}
                {selectedLayerId === layer.id && (
                  <div className="ml-2 p-4 bg-gray-50 rounded-lg border border-gray-200">
                    
                    {/* Content Editor */}
                    <div className="mb-4">
                      <label className="block text-sm font-medium mb-2 text-gray-700">
                        {layer.type === 'button' ? 'Button Text' : 'Text Content'}
                      </label>
                      {layer.type === 'text' ? (
                        <textarea
                          value={layer.content}
                          onChange={(e) => setLayers(prev => prev.map(l => 
                            l.id === layer.id ? { ...l, content: e.target.value } : l
                          ))}
                          className="w-full p-3 border border-gray-300 rounded-lg text-sm resize-none focus:ring-2 focus:ring-pink-500 focus:border-transparent"
                          rows={3}
                          placeholder="Enter your text here..."
                        />
                      ) : (
                        <input
                          type="text"
                          value={layer.content}
                          onChange={(e) => setLayers(prev => prev.map(l => 
                            l.id === layer.id ? { ...l, content: e.target.value } : l
                          ))}
                          className="w-full p-3 border border-gray-300 rounded-lg text-sm focus:ring-2 focus:ring-pink-500 focus:border-transparent"
                          placeholder="Enter button text..."
                        />
                      )}
                    </div>

                    {/* Style Controls */}
                    <div className="grid grid-cols-2 gap-4 mb-4">
                      <div>
                        <label className="block text-xs font-medium mb-2 text-gray-600">Font Size</label>
                        <input
                          type="range"
                          min="8"
                          max="72"
                          value={layer.style.fontSize || 16}
                          onChange={(e) => setLayers(prev => prev.map(l => 
                            l.id === layer.id ? { 
                              ...l, 
                              style: { ...l.style, fontSize: parseInt(e.target.value) }
                            } : l
                          ))}
                          className="w-full accent-pink-500"
                        />
                        <div className="text-xs text-gray-500 mt-1 text-center">{layer.style.fontSize || 16}px</div>
                      </div>
                      <div>
                        <label className="block text-xs font-medium mb-2 text-gray-600">Text Color</label>
                        <input
                          type="color"
                          value={layer.style.color || '#ffffff'}
                          onChange={(e) => setLayers(prev => prev.map(l => 
                            l.id === layer.id ? { 
                              ...l, 
                              style: { ...l.style, color: e.target.value }
                            } : l
                          ))}
                          className="w-full h-10 rounded-lg border border-gray-300 cursor-pointer"
                        />
                      </div>
                    </div>

                    {/* Background Color for buttons */}
                    {layer.type === 'button' && (
                      <div className="mb-4">
                        <label className="block text-xs font-medium mb-2 text-gray-600">Background Color</label>
                        <input
                          type="color"
                          value={layer.style.backgroundColor || '#3b82f6'}
                          onChange={(e) => setLayers(prev => prev.map(l => 
                            l.id === layer.id ? { 
                              ...l, 
                              style: { ...l.style, backgroundColor: e.target.value }
                            } : l
                          ))}
                          className="w-full h-10 rounded-lg border border-gray-300"
                        />
                      </div>
                    )}

                    {/* Text Shadow */}
                    <div className="mb-4">
                      <div className="flex items-center gap-2 mb-2">
                        <input
                          type="checkbox"
                          checked={!!layer.style.textShadow}
                          onChange={(e) => setLayers(prev => prev.map(l => 
                            l.id === layer.id ? { 
                              ...l, 
                              style: { 
                                ...l.style, 
                                textShadow: e.target.checked ? '2px 2px 4px rgba(0,0,0,0.8)' : undefined 
                              }
                            } : l
                          ))}
                          className="rounded accent-pink-500"
                        />
                        <label className="text-xs font-medium text-gray-600">Text Shadow</label>
                      </div>
                    </div>

                    {/* Position & Size */}
                    <div className="space-y-3">
                      <div className="grid grid-cols-2 gap-3">
                        <div>
                          <label className="block text-xs font-medium mb-1 text-gray-600">X Position</label>
                          <input
                            type="range"
                            min="0"
                            max={100 - layer.width}
                            value={layer.x}
                            onChange={(e) => setLayers(prev => prev.map(l => 
                              l.id === layer.id ? { ...l, x: parseFloat(e.target.value) } : l
                            ))}
                            className="w-full accent-pink-500"
                          />
                          <div className="text-xs text-gray-500 text-center">{Math.round(layer.x)}%</div>
                        </div>
                        <div>
                          <label className="block text-xs font-medium mb-1 text-gray-600">Y Position</label>
                          <input
                            type="range"
                            min="0"
                            max={100 - layer.height}
                            value={layer.y}
                            onChange={(e) => setLayers(prev => prev.map(l => 
                              l.id === layer.id ? { ...l, y: parseFloat(e.target.value) } : l
                            ))}
                            className="w-full accent-pink-500"
                          />
                          <div className="text-xs text-gray-500 text-center">{Math.round(layer.y)}%</div>
                        </div>
                      </div>
                      
                      <div className="grid grid-cols-2 gap-3">
                        <div>
                          <label className="block text-xs font-medium mb-1 text-gray-600">Width</label>
                          <input
                            type="range"
                            min="5"
                            max={100 - layer.x}
                            value={layer.width}
                            onChange={(e) => setLayers(prev => prev.map(l => 
                              l.id === layer.id ? { ...l, width: parseFloat(e.target.value) } : l
                            ))}
                            className="w-full accent-pink-500"
                          />
                          <div className="text-xs text-gray-500 text-center">{Math.round(layer.width)}%</div>
                        </div>
                        <div>
                          <label className="block text-xs font-medium mb-1 text-gray-600">Height</label>
                          <input
                            type="range"
                            min="5"
                            max={100 - layer.y}
                            value={layer.height}
                            onChange={(e) => setLayers(prev => prev.map(l => 
                              l.id === layer.id ? { ...l, height: parseFloat(e.target.value) } : l
                            ))}
                            className="w-full accent-pink-500"
                          />
                          <div className="text-xs text-gray-500 text-center">{Math.round(layer.height)}%</div>
                        </div>
                      </div>
                    </div>
                  </div>
                )}
              </div>
            ))}
          </div>

          {/* Image Layers */}
          {layers.filter(layer => layer.type === 'image' || layer.type === 'shape').length > 0 && (
            <div className="mt-6">
              <h3 className="font-medium text-gray-800 mb-4">Images & Shapes</h3>
              <div className="space-y-3">
                {layers.filter(layer => layer.type === 'image' || layer.type === 'shape').map((layer, index) => (
                  <div key={layer.id} className="space-y-2">
                    <div
                      className={`p-3 rounded-lg border cursor-pointer transition-all ${
                        selectedLayerId === layer.id 
                          ? 'border-pink-300 bg-pink-50' 
                          : 'border-gray-200 hover:border-gray-300'
                      }`}
                      onClick={() => setSelectedLayerId(selectedLayerId === layer.id ? null : layer.id)}
                    >
                      <div className="flex items-center justify-between mb-2">
                        <span className="text-sm font-medium text-gray-700">
                          {layer.type === 'image' ? 'Image' : `${layer.shapeType || 'Rectangle'} Shape`}
                        </span>
                        <div className="flex items-center gap-1">
                          <Button
                            size="sm"
                            variant="ghost"
                            onClick={(e) => {
                              e.stopPropagation()
                              setLayers(prev => prev.map(l => 
                                l.id === layer.id ? { ...l, visible: !l.visible } : l
                              ))
                            }}
                            className="p-1 h-6 w-6"
                          >
                            {layer.visible ? <Eye className="w-3 h-3" /> : <EyeOff className="w-3 h-3" />}
                          </Button>
                          <Button
                            size="sm"
                            variant="ghost"
                            onClick={(e) => {
                              e.stopPropagation()
                              setLayers(prev => prev.filter(l => l.id !== layer.id))
                              if (selectedLayerId === layer.id) {
                                setSelectedLayerId(null)
                              }
                            }}
                            className="p-1 h-6 w-6"
                          >
                            <Trash2 className="w-3 h-3" />
                          </Button>
                        </div>
                      </div>
                    </div>

                    {/* Image/Shape Properties */}
                    {selectedLayerId === layer.id && (
                      <div className="ml-2 p-4 bg-gray-50 rounded-lg border border-gray-200">
                        {layer.type === 'image' && (
                          <div className="mb-4">
                            <label className="block text-xs font-medium mb-2">Replace Image</label>
                            <input
                              type="file"
                              accept="image/*"
                              onChange={(e) => {
                                const file = e.target.files?.[0]
                                if (file) handleImageUpload(file)
                              }}
                              className="w-full text-xs"
                            />
                          </div>
                        )}

                        {/* Position Controls */}
                        <div className="grid grid-cols-2 gap-2 mb-3">
                          <div>
                            <label className="block text-xs font-medium mb-1">X: {Math.round(layer.x)}%</label>
                            <input
                              type="range"
                              min="0"
                              max={100 - layer.width}
                              value={layer.x}
                              onChange={(e) => setLayers(prev => prev.map(l => 
                                l.id === layer.id ? { ...l, x: parseFloat(e.target.value) } : l
                              ))}
                              className="w-full accent-pink-500"
                            />
                          </div>
                          <div>
                            <label className="block text-xs font-medium mb-1">Y: {Math.round(layer.y)}%</label>
                            <input
                              type="range"
                              min="0"
                              max={100 - layer.height}
                              value={layer.y}
                              onChange={(e) => setLayers(prev => prev.map(l => 
                                l.id === layer.id ? { ...l, y: parseFloat(e.target.value) } : l
                              ))}
                              className="w-full accent-pink-500"
                            />
                          </div>
                        </div>

                        {/* Size Controls */}
                        <div className="grid grid-cols-2 gap-2 mb-3">
                          <div>
                            <label className="block text-xs font-medium mb-1">Width: {Math.round(layer.width)}%</label>
                            <input
                              type="range"
                              min="5"
                              max={100 - layer.x}
                              value={layer.width}
                              onChange={(e) => setLayers(prev => prev.map(l => 
                                l.id === layer.id ? { ...l, width: parseFloat(e.target.value) } : l
                              ))}
                              className="w-full accent-pink-500"
                            />
                          </div>
                          <div>
                            <label className="block text-xs font-medium mb-1">Height: {Math.round(layer.height)}%</label>
                            <input
                              type="range"
                              min="5"
                              max={100 - layer.y}
                              value={layer.height}
                              onChange={(e) => setLayers(prev => prev.map(l => 
                                l.id === layer.id ? { ...l, height: parseFloat(e.target.value) } : l
                              ))}
                              className="w-full accent-pink-500"
                            />
                          </div>
                        </div>

                        {/* Shape Type Controls for Shape Layers */}
                        {layer.type === 'shape' && (
                          <div className="mb-3">
                            <label className="block text-xs font-medium mb-2">Shape Type</label>
                            <div className="grid grid-cols-2 gap-2">
                              <Button
                                size="sm"
                                variant={layer.shapeType === 'rectangle' ? 'primary' : 'outline'}
                                onClick={() => setLayers(prev => prev.map(l => 
                                  l.id === layer.id ? { ...l, shapeType: 'rectangle' } : l
                                ))}
                              >
                                <Square className="w-3 h-3 mr-1" />
                                Rectangle
                              </Button>
                              <Button
                                size="sm"
                                variant={layer.shapeType === 'circle' ? 'primary' : 'outline'}
                                onClick={() => setLayers(prev => prev.map(l => 
                                  l.id === layer.id ? { ...l, shapeType: 'circle' } : l
                                ))}
                              >
                                <Circle className="w-3 h-3 mr-1" />
                                Circle
                              </Button>
                              <Button
                                size="sm"
                                variant={layer.shapeType === 'triangle' ? 'primary' : 'outline'}
                                onClick={() => setLayers(prev => prev.map(l => 
                                  l.id === layer.id ? { ...l, shapeType: 'triangle' } : l
                                ))}
                              >
                                Triangle
                              </Button>
                              <Button
                                size="sm"
                                variant={layer.shapeType === 'rounded-rectangle' ? 'primary' : 'outline'}
                                onClick={() => setLayers(prev => prev.map(l => 
                                  l.id === layer.id ? { ...l, shapeType: 'rounded-rectangle' } : l
                                ))}
                              >
                                Rounded
                              </Button>
                            </div>
                          </div>
                        )}

                        {/* Image Shape Controls for Image Layers */}
                        {layer.type === 'image' && (
                          <div className="mb-3">
                            <label className="block text-xs font-medium mb-2">Image Shape</label>
                            <div className="flex gap-2">
                              <Button
                                size="sm"
                                variant={layer.imageShape === 'rectangle' ? 'primary' : 'outline'}
                                onClick={() => setLayers(prev => prev.map(l => 
                                  l.id === layer.id ? { ...l, imageShape: 'rectangle' } : l
                                ))}
                              >
                                <Square className="w-3 h-3" />
                              </Button>
                              <Button
                                size="sm"
                                variant={layer.imageShape === 'circle' ? 'primary' : 'outline'}
                                onClick={() => setLayers(prev => prev.map(l => 
                                  l.id === layer.id ? { ...l, imageShape: 'circle' } : l
                                ))}
                              >
                                <Circle className="w-3 h-3" />
                              </Button>
                              <Button
                                size="sm"
                                variant={layer.imageShape === 'rounded-rectangle' ? 'primary' : 'outline'}
                                onClick={() => setLayers(prev => prev.map(l => 
                                  l.id === layer.id ? { ...l, imageShape: 'rounded-rectangle' } : l
                                ))}
                              >
                                Rounded
                              </Button>
                            </div>
                          </div>
                        )}

                        {/* Color Controls */}
                        <div className="mb-3">
                          <label className="block text-xs font-medium mb-2">
                            {layer.type === 'shape' ? 'Shape Color' : 'Background Color'}
                          </label>
                          <input
                            type="color"
                            value={layer.style.backgroundColor || '#6366f1'}
                            onChange={(e) => setLayers(prev => prev.map(l => 
                              l.id === layer.id ? { 
                                ...l, 
                                style: { ...l.style, backgroundColor: e.target.value }
                              } : l
                            ))}
                            className="w-full h-10 rounded border border-gray-300"
                          />
                        </div>

                        {/* Color Overlay Controls for Image Layers */}
                        {layer.type === 'image' && (
                          <div className="mb-3">
                            <div className="flex items-center gap-2 mb-2">
                              <input
                                type="checkbox"
                                checked={layer.colorOverlay?.enabled || false}
                                onChange={(e) => setLayers(prev => prev.map(l => 
                                  l.id === layer.id ? { 
                                    ...l, 
                                    colorOverlay: { 
                                      ...(l.colorOverlay || { color: '#000000', opacity: 0.3 }),
                                      enabled: e.target.checked 
                                    }
                                  } : l
                                ))}
                              />
                              <label className="text-xs font-medium">Color Overlay</label>
                            </div>
                            
                            {layer.colorOverlay?.enabled && (
                              <div className="space-y-2 ml-4">
                                <div>
                                  <label className="block text-xs text-gray-500 mb-1">Overlay Color</label>
                                  <input
                                    type="color"
                                    value={layer.colorOverlay?.color || '#000000'}
                                    onChange={(e) => setLayers(prev => prev.map(l => 
                                      l.id === layer.id ? { 
                                        ...l, 
                                        colorOverlay: { 
                                          ...l.colorOverlay!,
                                          color: e.target.value 
                                        }
                                      } : l
                                    ))}
                                    className="w-full h-8 rounded border border-gray-300"
                                  />
                                </div>
                                <div>
                                  <label className="block text-xs text-gray-500 mb-1">
                                    Opacity: {Math.round((layer.colorOverlay?.opacity || 0.3) * 100)}%
                                  </label>
                                  <input
                                    type="range"
                                    min="0"
                                    max="1"
                                    step="0.1"
                                    value={layer.colorOverlay?.opacity || 0.3}
                                    onChange={(e) => setLayers(prev => prev.map(l => 
                                      l.id === layer.id ? { 
                                        ...l, 
                                        colorOverlay: { 
                                          ...l.colorOverlay!,
                                          opacity: parseFloat(e.target.value) 
                                        }
                                      } : l
                                    ))}
                                    className="w-full accent-pink-500"
                                  />
                                </div>
                              </div>
                            )}
                          </div>
                        )}
                      </div>
                    )}
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* Background Layer */}
          {layers.find(l => l.type === 'background') && (
            <div className="mt-6">
              <h3 className="font-medium text-gray-800 mb-4">Background Settings</h3>
              {(() => {
                const bgLayer = layers.find(l => l.type === 'background')
                if (!bgLayer) return null
                
                return (
                  <div className="space-y-2">
                    <div
                      className={`p-3 rounded-lg border cursor-pointer transition-all ${
                        selectedLayerId === bgLayer.id 
                          ? 'border-pink-300 bg-pink-50' 
                          : 'border-gray-200 hover:border-gray-300'
                      }`}
                      onClick={() => setSelectedLayerId(selectedLayerId === bgLayer.id ? null : bgLayer.id)}
                    >
                      <div className="flex items-center justify-between">
                        <span className="text-sm font-medium text-gray-700">Background Image</span>
                        <Button
                          size="sm"
                          variant="ghost"
                          onClick={(e) => {
                            e.stopPropagation()
                            setLayers(prev => prev.map(l => 
                              l.id === bgLayer.id ? { ...l, visible: !l.visible } : l
                            ))
                          }}
                        >
                          {bgLayer.visible ? 
                            <Eye className="w-3 h-3" /> : <EyeOff className="w-3 h-3" />
                          }
                        </Button>
                      </div>
                    </div>

                    {/* Background Properties - Show directly below selected layer */}
                    {selectedLayerId === bgLayer.id && (
                      <div className="ml-2 p-4 bg-gray-50 rounded-lg border">
                        <h4 className="font-medium mb-2 text-sm">Background Properties</h4>
                        
                        {/* Image Shape */}
                        <div className="mb-3">
                          <label className="block text-xs font-medium mb-2">Image Shape</label>
                          <div className="flex gap-2 mb-2">
                            <Button
                              size="sm"
                              variant={backgroundImageShape === 'rectangle' ? 'primary' : 'outline'}
                              onClick={() => setBackgroundImageShape('rectangle')}
                            >
                              <Square className="w-3 h-3" />
                            </Button>
                            <Button
                              size="sm"
                              variant={backgroundImageShape === 'circle' ? 'primary' : 'outline'}
                              onClick={() => setBackgroundImageShape('circle')}
                            >
                              <Circle className="w-3 h-3" />
                            </Button>
                            <Button
                              size="sm"
                              variant={backgroundImageShape === 'rounded-rectangle' ? 'primary' : 'outline'}
                              onClick={() => setBackgroundImageShape('rounded-rectangle')}
                            >
                              Rounded
                            </Button>
                          </div>
                        </div>

                        {/* Color Overlay */}
                        <div className="mb-3">
                          <div className="flex items-center gap-2 mb-2">
                            <input
                              type="checkbox"
                              checked={backgroundOverlay.enabled}
                              onChange={(e) => setBackgroundOverlay(prev => ({ ...prev, enabled: e.target.checked }))}
                            />
                            <label className="text-xs font-medium">Color Overlay</label>
                          </div>
                          
                          {backgroundOverlay.enabled && (
                            <div className="space-y-2 ml-4">
                              <div>
                                <label className="block text-xs text-gray-500 mb-1">Color</label>
                                <input
                                  type="color"
                                  value={backgroundOverlay.color}
                                  onChange={(e) => setBackgroundOverlay(prev => ({ ...prev, color: e.target.value }))}
                                  className="w-full h-8 rounded border border-gray-300"
                                />
                              </div>
                              <div>
                                <label className="block text-xs text-gray-500 mb-1">Opacity: {Math.round(backgroundOverlay.opacity * 100)}%</label>
                                <input
                                  type="range"
                                  min="0"
                                  max="1"
                                  step="0.1"
                                  value={backgroundOverlay.opacity}
                                  onChange={(e) => setBackgroundOverlay(prev => ({ ...prev, opacity: parseFloat(e.target.value) }))}
                                  className="w-full"
                                />
                              </div>
                            </div>
                          )}
                        </div>

                        {/* Position Controls for Background */}
                        <div className="grid grid-cols-2 gap-2 mb-3">
                          <div>
                            <label className="block text-xs font-medium mb-1">X: {Math.round(bgLayer.x)}%</label>
                            <input
                              type="range"
                              min="0"
                              max={100 - bgLayer.width}
                              value={bgLayer.x}
                              onChange={(e) => setLayers(prev => prev.map(l => 
                                l.id === bgLayer.id ? { ...l, x: parseFloat(e.target.value) } : l
                              ))}
                              className="w-full"
                            />
                          </div>
                          <div>
                            <label className="block text-xs font-medium mb-1">Y: {Math.round(bgLayer.y)}%</label>
                            <input
                              type="range"
                              min="0"
                              max={100 - bgLayer.height}
                              value={bgLayer.y}
                              onChange={(e) => setLayers(prev => prev.map(l => 
                                l.id === bgLayer.id ? { ...l, y: parseFloat(e.target.value) } : l
                              ))}
                              className="w-full"
                            />
                          </div>
                        </div>

                        {/* Size Controls for Background */}
                        <div className="grid grid-cols-2 gap-2">
                          <div>
                            <label className="block text-xs font-medium mb-1">Width: {Math.round(bgLayer.width)}%</label>
                            <input
                              type="range"
                              min="5"
                              max={100 - bgLayer.x}
                              value={bgLayer.width}
                              onChange={(e) => setLayers(prev => prev.map(l => 
                                l.id === bgLayer.id ? { ...l, width: parseFloat(e.target.value) } : l
                              ))}
                              className="w-full"
                            />
                          </div>
                          <div>
                            <label className="block text-xs font-medium mb-1">Height: {Math.round(bgLayer.height)}%</label>
                            <input
                              type="range"
                              min="5"
                              max={100 - bgLayer.y}
                              value={bgLayer.height}
                              onChange={(e) => setLayers(prev => prev.map(l => 
                                l.id === bgLayer.id ? { ...l, height: parseFloat(e.target.value) } : l
                              ))}
                              className="w-full"
                            />
                          </div>
                        </div>
                      </div>
                    )}
                  </div>
                )
              })()}
            </div>
          )}
        </div>

        {/* Export & Save Section */}
        <div className="p-4 border-t border-gray-200">
          <h4 className="font-medium text-gray-800 mb-3">Export & Save</h4>
          <p className="text-xs text-gray-600 mb-3">Download or save your finished creative</p>
          <div className="space-y-2">
            <Button 
              onClick={downloadImage}
              variant="outline"
              className="w-full flex items-center justify-center gap-2 py-2 text-purple-600 border-purple-200"
            >
              <Download className="w-4 h-4" />
              Download Image
            </Button>
            <Button 
              onClick={exportImage}
              className="w-full bg-pink-500 hover:bg-pink-600 text-white py-3 rounded-lg font-medium"
            >
              Save & Render
            </Button>
          </div>
        </div>

        {/* Canvas Settings */}
        <div className="mt-6">
          <h3 className="font-medium text-gray-800 mb-4">Canvas Settings</h3>
          <div className="space-y-3">
            <div>
              <label className="block text-xs font-medium mb-2">Canvas Background Color</label>
              <input
                type="color"
                value={canvasBackgroundColor}
                onChange={(e) => setCanvasBackgroundColor(e.target.value)}
                className="w-full h-10 rounded border border-gray-300"
              />
              <p className="text-xs text-gray-500 mt-1">This is the color behind all layers</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}

export default LayeredAdEditor 